import { execSync } from 'node:child_process'
import { env, exit } from 'node:process'
import { join } from 'node:path'
import { defineCommand } from 'citty'
import consola from 'consola'
import { ofetch } from 'ofetch'
import { fetchRepos } from '../../utils/github'
import { addPackage, getPackages, getPackagesPath, removePackage } from '../../utils/content'
import { getPackagesRedirectsPath } from '../../utils/config'
import type { GitHubRepo } from '../../types'

export const syncPackages = defineCommand({
  meta: {
    name: 'Sync Packages',
    description: 'Sync packages from repositories by creating PR (1 per diff)',
  },
  async run() {
    const repos = await fetchRepos()
    const packages = getPackages()

    // Repositories without a package (will create a PR to ADD)
    const reposWithoutPackage = repos.filter(repo => !packages.includes(repo.name))

    // Packages without a repository (will create a PR to REMOVE
    const packagesWithoutRepo = packages.filter(package_ => !repos.find(repo => repo.name === package_))

    execSync('git config user.name "barbapapazes"')
    execSync('git config user.email "e.soubiran25@gmail.com"')

    for (const repo of reposWithoutPackage)
      await createPR(repo.name, repos, 'add')

    for (const package_ of packagesWithoutRepo)
      await createPR(package_, repos, 'remove')
  },
})

async function createPR(package_: string, repos: GitHubRepo[], operation: 'add' | 'remove') {
  const owner = 'unjs'
  const repo = 'website'

  let branch: string = ''
  let type: string = ''
  let title: string = ''
  let description: string = ''

  if (operation === 'add') {
    branch = `feat/add-package/${package_}`
    type = 'feat'
    title = `add ${package_} package`
    description = `Add [\`${package_}\`](https://github.com/unjs/${package_}) package and redirection.`
  }
  else if (operation === 'remove') {
    branch = `fix/remove-package/${package_}`
    type = 'fix'
    title = `remove ${package_} package`
    description = `Remove \`${package_}\` package and redirection.`
  }

  try {
    execSync(`git checkout -b ${branch} origin/main`)
  }
  catch (err) {
    execSync(`git checkout ${branch}`)
  }

  if (operation === 'add') {
    const repo = repos.find(repo => repo.name === package_)
    if (!repo) {
      consola.fatal(`Repo ${package_} not found.`)
      exit(1)
    }
    addPackage(repo)
  }
  else if (operation === 'remove') {
    removePackage(package_)
  }

  execSync('pnpm run cli sync packages-redirects --format')

  const packagesRedirectsPath = getPackagesRedirectsPath()
  // Add redirects
  execSync(`git add ${packagesRedirectsPath}`)
  const packagesPath = getPackagesPath()
  // Add packages file
  execSync(`git add ${join(packagesPath, `${package_}.yml`)}`)
  try {
    execSync(`git commit -m "${type}: ${title}"`)
  }
  catch (err) {
    consola.info('No changes to commit.')
    exit(0)
  }
  execSync(`git push -u origin ${branch} --force`)

  const [currentPR] = await ofetch(`https://api.github.com/repos/${owner}/${repo}/pulls?head=${owner}:${branch}`)

  // Create PR if none exists
  if (!currentPR) {
    const verb = operation === 'add' ? 'Add' : 'Remove'
    return await ofetch(`https://api.github.com/repos/${owner}/${repo}/pulls`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${env.GITHUB_TOKEN}`,
      },
      body: {
        title: `${type}: ${title}`,
        head: `${owner}:${branch}`,
        base: 'main',
        body: `${description}\n\n- [ ] ${verb} the logo in \`assets/logos\`\n- [ ] ${verb} the puzzle part in \`assets/puzzle\`\n\n_This PR is automatically generated by a script._`,
      },
    })
  }
}
